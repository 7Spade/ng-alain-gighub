# ng-alain 開發作業指引

> 📋 **目的**：提供完整的開發規範、流程和最佳實踐，確保團隊成員遵循一致的開發標準

以下規範針對 `ng-alain`（Angular 20.3.x + NG-ZORRO 20.3.x + NG-ALAIN 20.1.x + SHARED_IMPORTS + Supabase MCP）調整，適用於 Windows 11 + Yarn 工作環境。所有成員在開始開發前請先熟讀並遵循。

**最後更新**：2025-11-16  
**維護者**：開發團隊

> **重要提示**：
> - 所有資料庫操作必須透過 `@SUPABASE` MCP 工具
> - UI 層採 `ChangeDetectionStrategy.OnPush` 與 Angular Signals
> - 保持 SHARED_IMPORTS 為主要導入入口
> - 系統採用 Git-like 分支模型，包含 51 張資料表，分為 11 個模組
> - ✅ **認證系統已實現**：Supabase Auth + @delon/auth 協作整合

---

## 一、開發前準備

### 1.1 架構理解

0. **認證系統架構** ✅  
   系統已完成 Supabase Auth + @delon/auth 的整合：
   - **Supabase Auth**：底層認證服務（signIn, signUp, signOut, Session 管理）
   - **SupabaseSessionAdapter**：Session 轉換層（將 Supabase Session 轉換為 @delon/auth Token 格式）
   - **@delon/auth**：前端認證框架（TokenService、路由守衛、HTTP 攔截器）
   - **AuthService**：業務層服務（整合 Supabase Auth 與 AccountRepository）
   - **AuthStateService**：認證狀態管理（使用 Angular Signals）
   - 實現位置：
     - `src/app/shared/services/auth/` - AuthService, AuthStateService
     - `src/app/core/supabase/supabase-session-adapter.service.ts` - Session 適配器
     - `src/app/core/repositories/account.repository.ts` - 帳戶資料訪問
   - 詳細說明請參考 `13-帳戶層流程圖.mermaid.md` 和 `14-業務流程圖.mermaid.md`

1. **Git-like 分支模型**  
   系統採用 Git-like 分支模型，包含：
   - **主分支 (blueprints)**：擁有者全權控制任務結構
   - **組織分支 (blueprint_branches)**：協作組織只能填寫承攬欄位
   - **Pull Request**：提交執行數據 → 擁有者審核 → 合併更新
   - **權限分離**：擁有者可修改任務結構，協作組織只能填寫承攬欄位
   - 詳細架構請參考 `27-完整架構流程圖.mermaid.md` 和 `28-架構審查報告.md`

2. **51 張資料表架構**  
   系統共包含 51 張資料表，分為 11 個模組：
   - 🔐 帳戶與身份系統（4 張）：accounts, teams, team_members, organization_schedules
   - 🤝 組織協作系統（3 張）：organization_collaborations, collaboration_invitations, collaboration_members
   - 🔒 權限系統（5 張）：roles, user_roles, permissions, role_permissions, branch_permissions
   - 🎯 藍圖/專案系統（5 張）：blueprints, blueprint_configs, blueprint_branches, branch_forks, pull_requests
   - 📋 任務執行系統（9 張）：tasks, task_assignments, task_lists, task_staging, daily_reports, report_photos, weather_cache, task_dependencies, task_templates
   - ✅ 品質驗收系統（4 張）：quality_checks, qc_photos, inspections, inspection_photos
   - ⚠️ 問題追蹤系統（4 張）：issues, issue_assignments, issue_photos, issue_sync_logs
   - 💬 協作溝通系統（6 張）：comments, notifications, notification_rules, notification_subscriptions, personal_todos, todo_status_tracking
   - 📊 資料分析系統（6 張）：documents, document_versions, document_thumbnails, progress_tracking, activity_logs, analytics_cache
   - 🤖 機器人系統（3 張）：bots, bot_tasks, bot_execution_logs
   - ⚙️ 系統管理（2 張）：settings, feature_flags
   - 完整表結構請參考 `30-0-完整SQL表結構定義.md`

3. **核心設計原則**  
   - **暫存區機制**：48 小時可撤回（`task_staging` 表）
   - **待辦中心**：五種狀態分類（待執行/暫存中/品管中/驗收中/問題追蹤）
   - **問題同步**：即時同步至主分支（`issue_sync_logs` 表）
   - **活動記錄**：集中記錄在主分支（`activity_logs` 表）
   - **文件管理**：版本控制、縮圖、軟刪除（30 天）
   - **數據同步**：施工日誌、品管記錄自動同步到主分支

### 1.2 MCP 工具使用規範

4. **Context7 先行**  
   在做任何技術決策或修改前，必須以 `@C7` 取得 Angular 20 / ng-alain 官方資訊或最佳實踐，確保實作對齊最新框架指引。

5. **Sequential Thinking + Software Planning Tool**  
   進入任務時依序執行 `@S7`（問題拆解）與 `@SPT`（產生/驗證實作計畫），獲得明確步驟後才可撰寫程式碼。

6. **Context7 + Sequential Thinking 用於跨模組重構**  
   多模組變更（例如調整共用 Service 或資料模型）必須先以 `@SC7` 或 `@SSC7` 產生跨模組分析與計畫，確認相依關係後再動工。

7. **MCP 工具使用規範**  
   - **Context7**：技術文檔檢索工具，實作前查詢官方文檔與最佳實踐
   - **Sequential Thinking**：複雜問題分析與決策，用於架構設計與根因分析
   - **Software Planning Tool**：Level 3 以上複雜任務必須使用，用於任務規劃與追蹤
   - **Memory**：記錄架構決策、技術債務、配置與測試結果，定期清理冗餘記憶
   - **Supabase MCP**：所有資料庫操作必須透過 `@SUPABASE` MCP 工具

### 1.3 規劃與任務管理

8. **規劃優先於實作**  
   所有開發工作必須先建立計畫項目（含複雜度、依賴、測試策略），經成員確認後才能進入 IMPLEMENT 階段。

9. **任務拆解步驟**  
   對應規劃中的每個子任務需列出 Step1/Step2/...，例如登入流程：檢查輸入 → 呼叫 `AuthService` → 更新 Signal 狀態 → 導向路由。

10. **結合規劃與驗證**  
    重大功能：`規劃 → AI 實作協助 → 單元測試/Playwright → lint/type-check → 更新文件 → 合併`；每個階段需記錄於任務追蹤工具。

11. **指令註記格式**  
    與 AI 或成員溝通程式碼片段時，使用 `@file`, `@class`, `@function` 標註來源，例如 `@file shared/services/auth.service.ts @function login`。

---

## 二、架構設計規範

### 2.1 專案結構與模組化

12. **專案結構一致性**  
   維持 feature-first 目錄與慣例命名：如 `routes/dashboard/`, `routes/blueprint/`, `shared/services/`, `core/infra/`。禁止建立與現有架構衝突的新目錄層級。

13. **模組化與單一職責**  
   每個 Angular Standalone Component、Service、Utility 專注單一職責；共享邏輯優先放入 `@shared` 與 `SHARED_IMPORTS` 管理。

14. **主入口明確**  
   `src/main.ts`/`src/app.config.ts` 必須匯入所有核心啟動模組，維持 APP Configuration 與 DI 清晰；禁止在 feature 範圍重複註冊 global provider。

15. **Git-like 分支模型實作**  
   - 藍圖管理：`routes/blueprint/` 模組負責主分支與分支管理
   - PR 機制：實作 Pull Request 審核與合併流程
   - 分支權限：嚴格控制分支層級權限（擁有者/協作組織/查看者）
   - 資料同步：實作分支數據自動同步至主分支機制

### 2.2 依賴關係與分層架構

16. **依賴關係與分層架構**  
    - 嚴格遵守分層依賴方向：routes → shared → core
    - 禁止 routes 直接依賴 core（除必要服務外）
    - 禁止 shared 直接依賴 routes
    - 使用 `inject()` 進行依賴注入，避免 constructor injection

17. **共享模組優先使用**  
    - 所有 UI 層組件必須優先使用 `SHARED_IMPORTS`
    - 禁止零碎引入 Angular、ng-zorro-antd、@delon 模組
    - 僅在 `SHARED_IMPORTS` 無法滿足需求時才個別導入
    - 保持模組導入的一致性與可維護性

18. **資料庫操作規範**  
    - 所有資料庫操作必須透過 Supabase MCP 工具（`@SUPABASE`）
    - 使用 `mcp_supabase_execute_sql` 執行查詢
    - 使用 `mcp_supabase_apply_migration` 執行 DDL 操作
    - 禁止在前端直接呼叫 Supabase Client（除查詢外）
    - 所有資料表操作需符合 51 張表的架構設計（參考 `30-0-完整SQL表結構定義.md`）

### 2.3 設計與實現同步

19. **設計與實現保持同步**  
    - 設計文檔應該反映實際實現，或明確標註差異
    - 架構變更需同步更新 `27-完整架構流程圖.mermaid.md`, `28-架構審查報告.md`, `30-0-完整SQL表結構定義.md` 等架構文檔

20. **模型定義對齊數據庫**  
    - TypeScript 模型應該精確反映數據庫結構
    - 51 張資料表的模型定義需與 `30-0-完整SQL表結構定義.md` 保持一致
    - 使用 Supabase MCP 工具生成 TypeScript 類型定義

21. **早期發現不一致**  
    - 使用 Supabase MCP 定期檢查數據庫結構
    - 使用 TypeScript 嚴格模式捕獲類型錯誤
    - 定期執行 `yarn type-check` 驗證類型一致性

22. **文檔化架構決策**  
    - 記錄為什麼選擇某種設計
    - 記錄與設計文檔的差異及原因
    - Git-like 分支模型的實作決策需記錄在架構文檔中

---

## 三、代碼規範

### 3.1 禁止事項

23. **禁止重複造輪**  
    - 實作前必須先搜尋專案內是否有現成解決方案
    - 優先重構或擴展現有功能，而非從零建立
    - 查閱 `SHARED_IMPORTS` 與公共模組，優先使用既有工具

24. **禁止「權宜式/懶惰式」修改**  
    - 禁止使用臨時 workaround、quick fix、hack 等權宜式解法
    - 必須採用結構化解法，完整思考問題根源
    - 提供可持續、可維護的解決方案，而非僅為快速解決問題

25. **禁止違反 Git-like 分支模型**  
    - 禁止協作組織修改任務結構（只能填寫承攬欄位）
    - 禁止繞過 PR 機制直接更新主分支數據
    - 禁止在分支中修改不屬於承攬欄位的資料

### 3.2 TypeScript 規範

26. **TypeScript 類型安全**  
    - 使用嚴格模式（strict mode）與明確類型標註
    - 避免使用 `any`，優先使用具體類型或 `unknown`
    - 利用類型推斷與類型守衛確保型別安全
    - 定期執行 `yarn type-check` 驗證類型一致性

27. **類型安全與 API 一致性規範**  
    - 類型匹配檢查：傳入參數前確認類型匹配，嵌套對象訪問正確屬性路徑
    - API 簽名驗證：調用服務方法前確認方法簽名，參數數量與類型完全匹配
    - 屬性路徑驗證：訪問嵌套屬性前確認路徑正確，參考模型定義避免假設
    - 明確類型標註：禁止隱含 `any` 類型，所有函數參數必須明確類型
    - 導入清理：提交前檢查並移除未使用的導入，使用 ESLint 規則自動檢測
    - 類型定義一致性：確保類型定義與實際使用一致，使用 `extends` 時確保父類型包含所需屬性
    - 資料表模型對齊：TypeScript 模型需與 51 張資料表結構對齊（參考 `30-0-完整SQL表結構定義.md`）

### 3.3 Angular 規範

28. **符合 Angular 20.3.x 最佳實踐**  
    - 優先使用 Standalone Components，避免使用 NgModules（除非必要）
    - 使用 Signals 進行響應式狀態管理（`signal()`, `computed()`, `effect()`）
    - 使用 `input()`, `output()`, `viewChild()`, `contentChild()` 替代舊裝飾器
    - 採用現代控制流程語法（`@if`、`@for`、`@switch`、`@defer`）
    - 使用 Typed Forms 確保表單類型安全
    - 使用 `inject()` 進行依賴注入，避免 constructor injection
    - 遵循 Angular 官方文檔與最佳實踐指南
    - 參考 `docs/45-SHARED_IMPORTS-使用指南.md` 了解詳細用法

29. **業務邏輯實作規範**  
    - **暫存區機制**：實作 48 小時可撤回功能（`task_staging` 表，`expires_at` 欄位）
    - **待辦中心**：實作五種狀態分類聚合（`personal_todos` 表：待執行/暫存中/品管中/驗收中/問題追蹤）
    - **問題同步**：實作跨分支問題即時同步機制（`issue_sync_logs` 表，`synced_to_main` 欄位）
    - **活動記錄**：所有操作統一記錄至主分支（`activity_logs` 表，所有分支活動同步）
    - **文件管理**：實作版本控制（`document_versions`）、縮圖生成（`document_thumbnails`）、軟刪除機制（30 天保留期）
    - **Git-like 分支模型**：實作主分支/組織分支/PR 機制，確保權限分離
    - **數據同步**：施工日誌（`daily_reports`）、品管記錄（`quality_checks`）自動同步到主分支

### 3.4 命名規範

30. **命名規範一致性**  
    - 遵循專案既有的命名慣例（檔案、類別、函數、變數）
    - 對齊路由規則、依賴匯入的一致性
    - 使用清晰的命名，避免縮寫與歧義
    - 保持模組、服務、組件的命名模式統一
    - 資料表與欄位命名遵循 snake_case（參考 `30-0-完整SQL表結構定義.md`）

---

## 四、開發流程規範

### 4.1 版本控制

31. **統一 Git 流程**  
   採 trunk-based 或 Git Flow：以 `feature/<name>` 開分支，commit 使用 Conventional Commits（如 `[feat] add auth guard`），完成後送 PR。

32. **版本控制規範**  
   - 使用語意化版本（Semantic Versioning）
   - 提交訊息遵循 Conventional Commits 格式
   - 重大變更需更新 CHANGELOG.md
   - 分支命名遵循規範（feature/、fix/、refactor/）
   - 提交前執行 lint 與 type-check

33. **變更前快照**  
   重大修改前建立 Git 標籤或快照（例如 `git tag pre-ai-refactor-v1.0`），必要時提交 `[refactor]` 類型的準備性 commit。

34. **大型變更的備份策略**  
   在套用 AI 產生的大量變更前，建立 Git 分支、標籤或備份檔案；必要時保留 `pre-ai-<feature>-ready` 標記以支援回溯。

35. **維護 CHANGELOG**  
   每個合併至主幹的功能/修正需更新 `CHANGELOG.md`，註記日期、版本、摘要與影響範圍。

36. **資料庫遷移規範**  
   - 所有資料庫變更必須透過 Supabase MCP 工具執行遷移
   - 遷移檔案需符合 51 張表的架構設計
   - 重大架構變更需先更新 `30-0-完整SQL表結構定義.md` 文檔
   - 遷移前需備份資料庫

### 4.2 開發實踐

37. **增量驗證**  
   每次只調整單一功能/檔案，完成後執行對應測試或 lint，確認無誤再進行下一步；禁止一次性大規模未驗證的修改。

38. **程式風格檢查**  
   提交前強制執行 `yarn lint`、`yarn format`（若有）、`yarn type-check`，確保符合專案 ESLint + Prettier 規範與嚴格型別要求。

39. **架構一致性檢查**  
   - 實作前確認是否符合 Git-like 分支模型設計
   - 確認資料表操作符合 51 張表的架構
   - 確認權限控制符合分支權限規則
   - 確認數據同步機制正確實作

---

## 五、質量保證規範

### 5.1 測試規範

40. **單元測試覆蓋**  
   新增或調整邏輯必須撰寫對應的 Jest/Karma 單元測試，並保持服務類別 ≥80% 覆蓋率、關鍵業務邏輯 100%。

41. **測試規範**  
   - 每個服務至少 80% 程式碼覆蓋率
   - 關鍵業務邏輯需 100% 覆蓋率（Git-like 分支模型、PR 機制、暫存區、問題同步等）
   - 使用 Angular Testing Utilities 進行組件測試
   - E2E 測試覆蓋關鍵用戶流程（藍圖建立、Fork、PR、任務執行等）
   - 定期執行 `yarn test-coverage` 驗證覆蓋率

42. **業務邏輯測試重點**  
   - 分支權限控制測試（擁有者/協作組織/查看者）
   - PR 審核與合併流程測試
   - 暫存區 48 小時撤回機制測試
   - 問題跨分支同步測試
   - 待辦中心五種狀態聚合測試

### 5.2 錯誤處理

43. **錯誤處理規範**  
   - 使用 `ErrorStateService` 統一管理錯誤狀態
   - HTTP 錯誤透過 `defaultInterceptor` 自動處理
   - 業務錯誤需明確分類（HTTP、網路、驗證、業務、權限）
   - 提供可重試機制與錯誤歷史記錄
   - 分支權限錯誤需明確提示（例如：協作組織嘗試修改任務結構）
   - PR 合併衝突需明確提示並提供解決方案

### 5.3 效能優化

34. **效能優化規範**  
    - 使用 `OnPush` 變更檢測策略（預設）
    - 避免在變更檢測期間直接修改 Signal/狀態
    - 使用 `trackBy` 函數優化 `@for` 迴圈
    - 大型列表使用虛擬滾動（Virtual Scrolling）
    - 圖片使用 `loading="lazy"` 延遲載入

### 5.4 API 設計

44. **API 設計規範**  
   - 使用 Repository 模式封裝資料存取邏輯
   - 統一回應格式與錯誤處理
   - 使用 TypeScript 類型定義 API 介面
   - 支援分頁、排序、篩選查詢參數
   - 實作請求快取與重試機制
   - 分支相關 API 需驗證權限（擁有者/協作組織/查看者）
   - PR 相關 API 需實作審核與合併邏輯

---

## 六、安全與合規規範

### 6.1 安全規範

45. **安全規範**  
   - 所有資料庫操作必須通過 Supabase MCP 工具
   - 啟用 Supabase RLS (Row Level Security) 檢查
   - 敏感資料不在前端儲存或傳輸
   - 使用環境變數管理 API Keys 與敏感配置
   - 定期檢查依賴套件的安全漏洞
   - 分支權限必須在資料庫層（RLS）與應用層雙重驗證
   - PR 合併操作必須驗證擁有者權限
   - 暫存區撤回操作必須驗證提交者身份

### 6.2 可訪問性規範

46. **可訪問性規範**  
   - 所有互動元素需提供適當的 ARIA 標籤
   - 鍵盤導航支援（Tab、Enter、Esc 等）
   - 顏色對比度符合 WCAG 2.1 AA 標準
   - 表單驗證錯誤需明確提示
   - 圖片提供替代文字（alt text）

---

## 七、文檔維護規範

47. **README 與程式地圖**  
   `README.md` 與各模組 `README` 必須同步更新：描述模組職責、主要類別/函式、依賴、測試入口，供 AI/開發者快速導覽。

48. **文件化程式**  
   每個公開類別、函式、Signal 狀態需提供 JSDoc/注解；檔案頂部加上模組級描述，說明用途、相依服務、輸出。

49. **範本化文件**  
   README、CONTRIBUTING、API 文件使用既定模板：包含安裝、指令、架構圖、API 說明、測試步驟與常見問題。

50. **文檔維護規範**  
   - 每個模組需提供 README.md 說明職責
   - 複雜邏輯需提供 JSDoc 註釋
   - 架構決策記錄在 AGENTS.md 中
    - 資料庫變更需同步更新模型定義（`30-0-完整SQL表結構定義.md`）
    - 架構變更需同步更新架構文檔（`27-完整架構流程圖.mermaid.md`, `28-架構審查報告.md`）
   - 定期檢查文檔與程式碼的一致性

51. **架構文檔同步**  
    - 實作 Git-like 分支模型功能時，需同步更新 `27-完整架構流程圖.mermaid.md` 流程圖
    - 新增資料表時，需同步更新 `30-0-完整SQL表結構定義.md` 表結構定義
   - 權限規則變更時，需同步更新 `21-安全與-RLS-權限矩陣.md`
   - 業務流程變更時，需同步更新相關流程圖文檔
