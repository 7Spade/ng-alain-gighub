# 新功能開發順序指南

> **適用範圍**：所有新功能模組（通用開發思維順序）  
> **架構模式**：五層架構（Types → Repositories → Models → Services → Facades）  
> **最後更新**：2025-01-19

---

## 📋 目錄

1. [開發前準備](#開發前準備)
2. [決策邏輯指南](#決策邏輯指南)
3. [五層架構開發順序](#五層架構開發順序)
4. [詳細開發步驟](#詳細開發步驟)
5. [檢查清單](#檢查清單)
6. [錯誤處理流程](#錯誤處理流程)
7. [常見問題 FAQ](#常見問題-faq)
8. [新功能模組開發示例](#新功能模組開發示例)

---

## 🎯 開發前準備

### 1. 需求分析

- [ ] 明確功能需求（PRD、用戶故事）
- [ ] 確認業務流程和規則
- [ ] 識別相關的現有模組和依賴
- [ ] 評估複雜度和優先級

### 2. 資料庫設計

- [ ] 設計資料表結構（對照 51 張表架構）
- [ ] 確認是否需要新增資料表
- [ ] 設計 RLS 策略（參考安全文檔）
- [ ] 準備資料庫遷移腳本
- [ ] 使用 `@SUPABASE` MCP 工具驗證設計

### 3. 架構規劃

- [ ] 確認功能屬於哪個業務模組（11 個模組之一）
- [ ] 規劃需要哪些層級（Types、Repositories、Models、Services、Facades）
- [ ] 確認與現有模組的整合點
- [ ] 設計 API 介面（如需要）

---

## 🔀 決策邏輯指南

在開發過程中，會遇到一些需要判斷的情況。本節提供明確的決策標準和流程。

### 決策 1：是否需要創建業務模組類型文件？

**判斷條件**：
- [ ] `database.types.ts` 是否包含所需的所有類型？
- [ ] 業務邏輯是否需要額外的類型定義（如枚舉、聯合類型、業務接口）？
- [ ] 是否需要業務相關的類型別名或工具類型？

**決策流程**：
```
檢查 database.types.ts
  ├─ 包含所需類型 → 不需要創建 {feature}.types.ts
  └─ 不包含 → 檢查業務需求
      ├─ 需要額外類型定義 → 創建 {feature}.types.ts
      └─ 不需要 → 不需要創建
```

**示例場景**：
- ✅ **需要創建**：業務邏輯需要 `TransactionType` 枚舉、`TransactionSummary` 接口等
- ❌ **不需要創建**：只需要使用 `database.types.ts` 中的基礎類型

---

### 決策 2：是否需要整合活動記錄？

**判斷條件**：
- [ ] 功能是否需要記錄用戶操作？
- [ ] 是否需要審計追蹤？
- [ ] 是否需要活動時間軸？

**決策流程**：
```
檢查業務需求
  ├─ 需要記錄操作/審計追蹤 → 整合 BlueprintActivityService
  └─ 不需要 → 跳過活動記錄
```

**示例場景**：
- ✅ **需要整合**：創建、更新、刪除等關鍵操作需要記錄
- ❌ **不需要整合**：純查詢功能或內部工具

---

### 決策 3：是否需要特定查詢方法？

**判斷條件**：
- [ ] BaseRepository 的 `findAll()` 是否足夠？
- [ ] 是否需要複雜的查詢邏輯（多條件、關聯查詢）？
- [ ] 查詢邏輯是否會被多處使用？

**決策流程**：
```
檢查查詢需求
  ├─ BaseRepository.findAll() 足夠 → 不需要添加
  └─ 需要複雜查詢 → 添加特定查詢方法
      ├─ 單一使用 → 在 Service 層實現
      └─ 多處使用 → 在 Repository 層實現
```

**示例場景**：
- ✅ **需要添加**：`findByOwnerIdAndStatus()`、`findActiveItems()` 等常用查詢
- ❌ **不需要添加**：簡單的單條件查詢，使用 `findAll({ filters: {...} })` 即可

---

### 決策 4：是否需要多個 Services？

**判斷條件**：
- [ ] 功能模組是否包含多個獨立的業務領域？
- [ ] 不同業務領域的職責是否清晰分離？
- [ ] 是否會導致 Service 過於龐大（>500 行）？

**決策流程**：
```
檢查業務複雜度
  ├─ 單一業務領域 → 單一 Service
  └─ 多個業務領域 → 拆分為多個 Services
      ├─ 職責清晰分離 → 分別創建 Service
      └─ 職責重疊 → 合併為單一 Service
```

**示例場景**：
- ✅ **需要拆分**：財務模組包含「交易管理」和「報表分析」兩個獨立領域
- ❌ **不需要拆分**：功能簡單，單一 Service 即可

---

## 🏗️ 五層架構開發順序

### 架構層級圖

```
┌─────────────────────────────────────┐
│   Facades 層（門面層）              │  ← 第 5 步：最後開發
├─────────────────────────────────────┤
│   Services 層（業務邏輯層）         │  ← 第 4 步：依赖 Repositories + Models
├─────────────────────────────────────┤
│   Models 層（數據模型層）           │  ← 第 3 步：依赖 Types（可與 Repositories 並行）
├─────────────────────────────────────┤
│   Repositories 層（數據訪問層）     │  ← 第 2 步：依赖 Types
├─────────────────────────────────────┤
│   Types 層（類型定義層）            │  ← 第 1 步：最底層，最先開發
└─────────────────────────────────────┘
```

### 標準開發流程

```
第 1 步：Types 层（必須最先完成）
  ↓
第 2 步：Repositories 层（依赖 Types）
  ↓
第 3 步：Models 层（依赖 Types，可與 Repositories 並行）
  ↓
第 4 步：Services 层（依赖 Repositories + Models）
  ↓
第 5 步：Facades 层（依赖 Services）
  ↓
第 6 步：Routes/Components 层（依赖 Facades）
  ↓
第 7 步：測試與文檔
```

---

## 📝 詳細開發步驟

### 第 1 步：Types 層（最底層）

**優先級**：P0（必須最先完成）

**位置**：`src/app/core/infra/types/`

**職責**：
- 從 Supabase 生成 `database.types.ts`（包含所有表的類型）
- 定義業務模組類型文件（如 `finance.types.ts`）

**依賴**：無（最底層）

**開發步驟**：

1. **生成/更新 database.types.ts**
   ```bash
   # 使用 Supabase MCP 工具生成類型
   # 確保新表已包含在類型定義中
   ```

2. **創建業務模組類型文件**（如需要）
   ```typescript
   // src/app/core/infra/types/{feature}.types.ts
   import { Database } from './database.types';
   
   // 從 database.types.ts 提取類型
   export type FeatureItem = Database['public']['Tables']['feature_items']['Row'];
   export type FeatureItemInsert = Database['public']['Tables']['feature_items']['Insert'];
   export type FeatureItemUpdate = Database['public']['Tables']['feature_items']['Update'];
   
   // 業務相關類型定義
   export type ItemType = 'type1' | 'type2' | 'type3';
   export type ItemStatus = 'active' | 'inactive' | 'archived';
   ```

3. **導出類型**
   ```typescript
   // src/app/core/infra/types/index.ts
   export * from './finance.types';
   ```

**檢查清單**：
- [ ] 所有新表的類型定義已包含在 `database.types.ts`
- [ ] 業務模組類型文件已創建（如需要）
- [ ] 類型已正確導出
- [ ] 類型定義與資料庫結構一致
- [ ] 通過 TypeScript 編譯檢查（`yarn type-check`）

---

### 第 2 步：Repositories 層

**優先級**：P0（依賴 Types 層）

**位置**：`src/app/core/infra/repositories/`

**職責**：
- 封裝資料庫訪問
- 處理 snake_case ↔ camelCase 轉換
- 統一錯誤處理

**依賴**：
- ✅ Types 層（必須）
- ✅ BaseRepository（基礎設施）
- ✅ SupabaseService（基礎設施）

**開發步驟**：

1. **創建 Repository 文件**
   ```typescript
   // src/app/core/infra/repositories/{feature}-item.repository.ts
   import { Injectable, inject } from '@angular/core';
   import { Observable } from 'rxjs';
   import { BaseRepository, QueryOptions } from '@core';
   import { 
     FeatureItem, 
     FeatureItemInsert, 
     FeatureItemUpdate 
   } from '@core';
   
   @Injectable({ providedIn: 'root' })
   export class FeatureItemRepository extends BaseRepository<
     FeatureItem,
     FeatureItemInsert,
     FeatureItemUpdate
   > {
     protected tableName = 'feature_items';
     
     // 可選：添加特定查詢方法
     findByOwnerId(ownerId: string, options?: QueryOptions): Observable<FeatureItem[]> {
       return this.findAll({
         ...options,
         filters: {
           ...options?.filters,
           ownerId, // 會自動轉換為 owner_id
         },
       });
     }
     
     findByStatus(status: ItemStatus, options?: QueryOptions): Observable<FeatureItem[]> {
       return this.findAll({
         ...options,
         filters: {
           ...options?.filters,
           status,
         },
       });
     }
   }
   ```

2. **導出 Repository**
   ```typescript
   // src/app/core/infra/repositories/index.ts
   export * from './{feature}-item.repository';
   ```

3. **在 core/index.ts 中導出**
   ```typescript
   // src/app/core/index.ts
   export * from './infra/repositories';
   ```

**檢查清單**：
- [ ] Repository 繼承自 `BaseRepository`
- [ ] `tableName` 已正確設置
- [ ] 類型參數正確（Entity, Insert, Update）
- [ ] 特定查詢方法已實現（如需要）
- [ ] Repository 已正確導出
- [ ] 通過 TypeScript 編譯檢查
- [ ] 測試基本 CRUD 操作（可選，但建議）

---

### 第 3 步：Models 層（可與 Repositories 並行）

**優先級**：P0（可與 Repositories 並行開發）

**位置**：`src/app/shared/models/`

**職責**：
- 定義業務模型（camelCase）
- 提供業務相關的類型定義和枚舉

**依賴**：
- ✅ Types 層（必須，用於類型提取）
- ⚠️ 可參考 Repositories（但不強制依賴）

**開發步驟**：

1. **創建 Models 文件**
   ```typescript
   // src/app/shared/models/{feature}.models.ts
   import { FeatureItem } from '@core';
   
   // 從 Types 層提取並轉換為業務模型
   export type FeatureItemModel = FeatureItem;
   
   // 業務相關枚舉
   export enum ItemType {
     TYPE1 = 'type1',
     TYPE2 = 'type2',
     TYPE3 = 'type3',
   }
   
   export enum ItemStatus {
     ACTIVE = 'active',
     INACTIVE = 'inactive',
     ARCHIVED = 'archived',
   }
   
   // 業務相關類型
   export interface ItemSummary {
     totalCount: number;
     activeCount: number;
     inactiveCount: number;
   }
   
   // 業務相關接口
   export interface CreateItemRequest {
     name: string;
     type: ItemType;
     description?: string;
   }
   ```

2. **導出 Models**
   ```typescript
   // src/app/shared/models/index.ts
   export * from './{feature}.models';
   ```

**檢查清單**：
- [ ] Models 文件已創建
- [ ] 從 Types 層正確提取類型
- [ ] 業務相關枚舉和類型已定義
- [ ] Models 已正確導出
- [ ] 通過 TypeScript 編譯檢查

---

### 第 4 步：Services 層

**優先級**：P0（依賴 Repositories + Models）

**位置**：`src/app/shared/services/`

**職責**：
- 業務邏輯處理
- 狀態管理（使用 Signals）
- 協調多個 Repositories

**依賴**：
- ✅ Repositories 層（必須）
- ✅ Models 層（必須）
- ✅ Angular Signals（狀態管理）

**開發步驟**：

1. **創建 Service 文件**
   ```typescript
   // src/app/shared/services/{feature}/{feature}-item.service.ts
   import { Injectable, inject, signal, computed } from '@angular/core';
   import { Observable, firstValueFrom } from 'rxjs';
   import { FeatureItemRepository } from '@core';
   import { 
     FeatureItemModel, 
     ItemType, 
     ItemStatus,
     CreateItemRequest,
     ItemSummary 
   } from '@shared';
   
   @Injectable({ providedIn: 'root' })
   export class FeatureItemService {
     private readonly itemRepo = inject(FeatureItemRepository);
     
     // 使用 Signals 管理狀態
     private itemsState = signal<FeatureItemModel[]>([]);
     private selectedItemState = signal<FeatureItemModel | null>(null);
     private loadingState = signal<boolean>(false);
     private errorState = signal<string | null>(null);
     
     // 暴露 ReadonlySignal 給組件
     readonly items = this.itemsState.asReadonly();
     readonly selectedItem = this.selectedItemState.asReadonly();
     readonly loading = this.loadingState.asReadonly();
     readonly error = this.errorState.asReadonly();
     
     // Computed signals
     readonly activeItems = computed(() => 
       this.items().filter(item => item.status === ItemStatus.ACTIVE)
     );
     
     readonly summary = computed<ItemSummary>(() => {
       const items = this.items();
       return {
         totalCount: items.length,
         activeCount: items.filter(i => i.status === ItemStatus.ACTIVE).length,
         inactiveCount: items.filter(i => i.status === ItemStatus.INACTIVE).length,
       };
     });
     
     // 業務邏輯方法
     async loadItems(ownerId: string): Promise<void> {
       this.loadingState.set(true);
       this.errorState.set(null);
       
       try {
         const items = await firstValueFrom(
           this.itemRepo.findByOwnerId(ownerId)
         );
         this.itemsState.set(items);
       } catch (error) {
         this.errorState.set(error instanceof Error ? error.message : 'Unknown error');
         throw error;
       } finally {
         this.loadingState.set(false);
       }
     }
     
     async createItem(request: CreateItemRequest): Promise<FeatureItemModel> {
       this.loadingState.set(true);
       this.errorState.set(null);
       
       try {
         const newItem = await firstValueFrom(
           this.itemRepo.create({
             name: request.name,
             type: request.type,
             description: request.description,
             status: ItemStatus.ACTIVE,
           })
         );
         
         // 更新狀態
         this.itemsState.update(items => [...items, newItem]);
         
         return newItem;
       } catch (error) {
         this.errorState.set(error instanceof Error ? error.message : 'Unknown error');
         throw error;
       } finally {
         this.loadingState.set(false);
       }
     }
     
     // 更多業務邏輯方法...
   }
   ```

2. **導出 Service**
   ```typescript
   // src/app/shared/services/{feature}/index.ts
   export * from './{feature}-item.service';
   ```

3. **在 shared/services/index.ts 中導出**
   ```typescript
   // src/app/shared/services/index.ts
   export * from './{feature}';
   ```

**檢查清單**：
- [ ] Service 使用 `@Injectable({ providedIn: 'root' })`
- [ ] 使用 `inject()` 進行依賴注入
- [ ] 使用 Signals 管理狀態（`signal()`, `computed()`）
- [ ] 暴露 `ReadonlySignal` 給組件
- [ ] 業務邏輯方法已實現
- [ ] 錯誤處理已實現
- [ ] Loading 狀態管理已實現
- [ ] Service 已正確導出
- [ ] 通過 TypeScript 編譯檢查
- [ ] 單元測試已編寫（建議 ≥80% 覆蓋率）

---

### 第 5 步：Facades 層

**優先級**：P0（依賴 Services 層）

**位置**：`src/app/core/facades/`

**職責**：
- 業務模組門面，統一對外接口
- 協調多個 Services
- 提供統一的 Signal 狀態接口

**依賴**：
- ✅ Services 層（必須）
- ✅ ErrorStateService（錯誤處理）
- ✅ BlueprintActivityService（活動記錄，如需要）

**開發步驟**：

1. **創建 Facade 文件**
   ```typescript
   // src/app/core/facades/{feature}.facade.ts
   import { Injectable, inject, signal, computed, effect, OnDestroy } from '@angular/core';
   import { FeatureItemService } from '@shared';
   import { ErrorStateService, BlueprintActivityService } from '@shared';
   import { 
     FeatureItemModel, 
     ItemType,
     CreateItemRequest,
     ItemSummary 
   } from '@shared';
   
   /**
    * Feature Facade
    *
    * {功能名稱}模組門面，統一對外接口
    * 協調 FeatureItemService 等服務
    */
   @Injectable({ providedIn: 'root' })
   export class FeatureFacade implements OnDestroy {
     private readonly itemService = inject(FeatureItemService);
     private readonly errorState = inject(ErrorStateService);
     private readonly activityService = inject(BlueprintActivityService);
     
     // 暴露 Service 的狀態（通過 Facade）
     readonly items = this.itemService.items;
     readonly selectedItem = this.itemService.selectedItem;
     readonly loading = this.itemService.loading;
     readonly error = this.itemService.error;
     
     // Facade 層的 Computed signals
     readonly summary = this.itemService.summary;
     
     // 業務方法（委託給 Service）
     async loadItems(ownerId: string): Promise<void> {
       try {
         await this.itemService.loadItems(ownerId);
       } catch (error) {
         this.errorState.setError('feature', error);
         throw error;
       }
     }
     
     async createItem(request: CreateItemRequest): Promise<FeatureItemModel> {
       try {
         const item = await this.itemService.createItem(request);
         
         // 記錄活動（如需要）
         await this.activityService.logActivity({
           blueprintId: ownerId, // 根據實際業務調整
           action: 'feature_item_created',
           details: { itemId: item.id },
         });
         
         return item;
       } catch (error) {
         this.errorState.setError('feature', error);
         throw error;
       }
     }
     
     ngOnDestroy(): void {
       // 清理資源（如需要）
     }
   }
   ```

2. **導出 Facade**
   ```typescript
   // src/app/core/facades/index.ts
   export * from './{feature}.facade';
   ```

3. **在 core/index.ts 中導出**
   ```typescript
   // src/app/core/index.ts
   export * from './facades';
   ```

**檢查清單**：
- [ ] Facade 使用 `@Injectable({ providedIn: 'root' })`
- [ ] 協調多個 Services（如需要）
- [ ] 暴露統一的 Signal 狀態接口
- [ ] 整合錯誤處理（ErrorStateService）
- [ ] 整合活動記錄（如需要）
- [ ] 業務方法已實現
- [ ] Facade 已正確導出
- [ ] 通過 TypeScript 編譯檢查
- [ ] 單元測試已編寫（建議 ≥80% 覆蓋率）

---

### 第 6 步：Routes/Components 層

**優先級**：P0（依賴 Facades 層）

**位置**：`src/app/routes/`

**職責**：
- UI 組件實現
- 用戶交互處理
- 路由配置

**依賴**：
- ✅ Facades 層（必須）
- ✅ SHARED_IMPORTS（UI 組件）

**開發步驟**：

1. **創建組件**
   ```typescript
   // src/app/routes/{feature}/{feature}-list/{feature}-list.component.ts
   import { Component, inject, OnInit } from '@angular/core';
   import { SHARED_IMPORTS } from '@shared';
   import { FeatureFacade } from '@core';
   
   @Component({
     selector: 'app-{feature}-list',
     standalone: true,
     imports: [SHARED_IMPORTS],
     templateUrl: './{feature}-list.component.html',
     styleUrl: './{feature}-list.component.less',
   })
   export class FeatureListComponent implements OnInit {
     private readonly featureFacade = inject(FeatureFacade);
     
     // 從 Facade 獲取狀態
     readonly items = this.featureFacade.items;
     readonly loading = this.featureFacade.loading;
     readonly summary = this.featureFacade.summary;
     
     ngOnInit(): void {
       // 加載數據
       this.featureFacade.loadItems('owner-id');
     }
   }
   ```

2. **配置路由**
   ```typescript
   // src/app/routes/{feature}/{feature}.routes.ts
   import { Routes } from '@angular/router';
   
   export const featureRoutes: Routes = [
     {
       path: '',
       loadComponent: () => import('./{feature}-list/{feature}-list.component')
         .then(m => m.FeatureListComponent),
       data: { title: '{功能名稱}' },
     },
   ];
   ```

**檢查清單**：
- [ ] 組件使用 Standalone Component
- [ ] 使用 `SHARED_IMPORTS` 導入模組
- [ ] 使用 `inject()` 注入 Facade
- [ ] 從 Facade 獲取狀態（ReadonlySignal）
- [ ] 路由已配置
- [ ] UI/UX 符合設計規範
- [ ] 響應式設計已實現
- [ ] 可訪問性要求已滿足
- [ ] 通過 TypeScript 編譯檢查

---

### 第 7 步：測試與文檔

**優先級**：P0（必須完成）

**開發步驟**：

1. **單元測試**
   - [ ] Repository 測試（可選，但建議）
   - [ ] Service 測試（必須，≥80% 覆蓋率）
   - [ ] Facade 測試（必須，≥80% 覆蓋率）
   - [ ] Component 測試（建議）

2. **集成測試**
   - [ ] 端到端測試（如需要）
   - [ ] API 集成測試（如需要）

3. **文檔**
   - [ ] README 更新（如需要）
   - [ ] API 文檔更新（如需要）
   - [ ] 架構文檔更新（如需要）

**檢查清單**：
- [ ] 所有測試通過
- [ ] 測試覆蓋率達標（≥80%）
- [ ] 文檔已更新
- [ ] 代碼審查通過

---

## ✅ 檢查清單（企業標準）

### 開發前檢查

#### 1. 需求分析
- [ ] 明確功能需求（PRD、用戶故事）
- [ ] 確認業務流程和規則
- [ ] 識別相關的現有模組和依賴
- [ ] 評估複雜度和優先級
- [ ] **常見做法檢查**：參考項目中已有的類似實現，保持一致性

#### 2. 資料庫設計
- [ ] 設計資料表結構（對照 51 張表架構）
- [ ] 確認是否需要新增資料表
- [ ] 設計 RLS 策略（參考安全文檔）
- [ ] 準備資料庫遷移腳本
- [ ] 使用 `@SUPABASE` MCP 工具驗證設計
- [ ] **企業標準檢查**：資料表設計符合規範，RLS 策略完整

#### 3. 架構規劃
- [ ] 確認功能屬於哪個業務模組（11 個模組之一）
- [ ] 規劃需要哪些層級（Types、Repositories、Models、Services、Facades）
- [ ] 確認與現有模組的整合點
- [ ] 設計 API 介面（如需要）
- [ ] **邏輯一致性檢查**：架構規劃符合分層架構原則，依賴關係清晰

#### 4. 開發準備
- [ ] 分支已創建（遵循分支命名規範）
- [ ] 開發環境已準備
- [ ] 相關文檔已閱讀

---

### 開發中檢查（按開發順序）

#### 第 1 步：Types 層檢查

**完成標準**：
- [ ] 使用 Supabase MCP 生成/更新 `database.types.ts`（如需要新表）
- [ ] 創建業務模組類型文件 `{feature}.types.ts`（如需要）
- [ ] 類型定義完整，與資料庫結構一致
- [ ] 類型已正確導出（在 `core/infra/types/index.ts` 中）
- [ ] 通過 TypeScript 編譯檢查（`yarn type-check`）

**企業標準檢查**：
- [ ] **常見做法**：類型定義遵循 TypeScript 最佳實踐
- [ ] **企業標準**：類型定義完整，無 `any` 類型（除非必要）
- [ ] **邏輯一致性**：類型命名語義化，與資料庫字段對應
- [ ] **符合常理**：類型定義可用，編譯無錯誤

---

#### 第 2 步：Repositories 層檢查

**完成標準**：
- [ ] Repository 繼承自 `BaseRepository`
- [ ] `tableName` 已正確設置（snake_case）
- [ ] 類型參數正確（Entity, Insert, Update）
- [ ] 特定查詢方法已實現（如需要）
- [ ] Repository 已正確導出（在 `core/infra/repositories/index.ts` 中）
- [ ] 通過 TypeScript 編譯檢查

**企業標準檢查**：
- [ ] **常見做法**：遵循 Repository 模式，參考現有 Repository 實現
- [ ] **企業標準**：代碼結構清晰，職責分離明確（只負責數據訪問）
- [ ] **邏輯一致性**：查詢方法命名語義化，參數類型正確
- [ ] **符合常理**：基本 CRUD 操作可用，查詢方法正確

---

#### 第 3 步：Models 層檢查（可與 Repositories 並行）

**完成標準**：
- [ ] Models 文件已創建 `{feature}.models.ts`
- [ ] 從 Types 層正確提取類型
- [ ] 業務相關枚舉和類型已定義
- [ ] 業務相關接口已定義
- [ ] Models 已正確導出（在 `shared/models/index.ts` 中）
- [ ] 通過 TypeScript 編譯檢查

**企業標準檢查**：
- [ ] **常見做法**：參考現有 Models 文件結構
- [ ] **企業標準**：模型定義完整，枚舉值明確
- [ ] **邏輯一致性**：模型命名語義化，與業務邏輯對應
- [ ] **符合常理**：模型定義可用，類型正確

---

#### 第 4 步：Services 層檢查

**完成標準**：
- [ ] Service 使用 `@Injectable({ providedIn: 'root' })`
- [ ] 使用 `inject()` 進行依賴注入
- [ ] 使用 Signals 管理狀態（`signal()`, `computed()`）
- [ ] 暴露 `ReadonlySignal` 給組件
- [ ] 業務邏輯方法已實現
- [ ] 錯誤處理已實現（try-catch，錯誤狀態管理）
- [ ] Loading 狀態管理已實現
- [ ] Service 已正確導出（在 `shared/services/{feature}/index.ts` 中）
- [ ] 通過 TypeScript 編譯檢查

**企業標準檢查**：
- [ ] **常見做法**：遵循 Angular 20 現代語法，參考現有 Service 實現
- [ ] **企業標準**：
  - [ ] 代碼結構清晰，職責分離明確（業務邏輯處理）
  - [ ] 錯誤處理完善（所有異步操作都有錯誤處理）
  - [ ] 狀態管理規範（使用 Signals，避免全局狀態污染）
  - [ ] 測試覆蓋完整（關鍵業務邏輯有單元測試，≥80% 覆蓋率）
- [ ] **邏輯一致性**：
  - [ ] 數據流清晰（Service → Repository → Database）
  - [ ] 命名語義化（方法名清楚表達意圖）
  - [ ] 狀態更新時機正確（loading 狀態配對設置和清除）
- [ ] **符合常理**：
  - [ ] 功能真正可用（不是"看起來完成"）
  - [ ] 錯誤提示用戶友好
  - [ ] 狀態管理正確（不會導致無限加載等問題）

---

#### 第 5 步：Facades 層檢查

**完成標準**：
- [ ] Facade 使用 `@Injectable({ providedIn: 'root' })`
- [ ] 協調多個 Services（如需要）
- [ ] 暴露統一的 Signal 狀態接口
- [ ] 整合錯誤處理（ErrorStateService）
- [ ] 整合活動記錄（如需要，BlueprintActivityService）
- [ ] 業務方法已實現（委託給 Service）
- [ ] Facade 已正確導出（在 `core/facades/index.ts` 中）
- [ ] 通過 TypeScript 編譯檢查

**企業標準檢查**：
- [ ] **常見做法**：遵循 Facade 模式，參考現有 Facade 實現
- [ ] **企業標準**：
  - [ ] 代碼結構清晰，職責分離明確（統一對外接口）
  - [ ] 錯誤處理完善（整合 ErrorStateService）
  - [ ] 狀態管理規範（暴露 ReadonlySignal）
- [ ] **邏輯一致性**：
  - [ ] 數據流清晰（Facade → Service → Repository）
  - [ ] 命名語義化（方法名清楚表達意圖）
- [ ] **符合常理**：
  - [ ] 功能真正可用
  - [ ] 接口統一，易於使用

---

#### 第 6 步：Routes/Components 層檢查

**完成標準**：
- [ ] 組件使用 Standalone Component
- [ ] 使用 `SHARED_IMPORTS` 導入模組
- [ ] 使用 `inject()` 注入 Facade
- [ ] 從 Facade 獲取狀態（ReadonlySignal）
- [ ] 路由已配置（懶加載）
- [ ] UI/UX 符合設計規範
- [ ] 響應式設計已實現
- [ ] 可訪問性要求已滿足（WCAG 2.1 AA）
- [ ] 通過 TypeScript 編譯檢查

**企業標準檢查**：
- [ ] **常見做法**：
  - [ ] 遵循 Angular 20 現代語法（Standalone Components）
  - [ ] 使用 SHARED_IMPORTS，避免碎片化導入
  - [ ] UI/UX 符合常規（列表頁只查看，詳情頁編輯刪除）
- [ ] **企業標準**：
  - [ ] 代碼結構清晰，職責分離明確（UI 展示和用戶交互）
  - [ ] 錯誤處理完善（顯示錯誤提示）
  - [ ] 狀態管理規範（從 Facade 獲取狀態，不直接修改）
- [ ] **邏輯一致性**：
  - [ ] 數據流清晰（Component → Facade → Service）
  - [ ] 命名語義化（組件名清楚表達意圖）
  - [ ] 組件初始化順序正確（優先加載主要功能）
- [ ] **符合常理**：
  - [ ] 功能真正可用（不是"看起來完成"）
  - [ ] 用戶體驗良好（符合使用習慣）
  - [ ] 避免過度設計（簡單有效的方案）

---

#### 第 7 步：測試與文檔檢查

**完成標準**：
- [ ] 單元測試已編寫（Repository、Service、Facade）
- [ ] 測試覆蓋率達標（≥80% 服務層，100% 關鍵業務邏輯）
- [ ] 所有測試通過（`yarn test`）
- [ ] 文檔已更新（README、API 文檔、架構文檔）

**企業標準檢查**：
- [ ] **常見做法**：遵循測試最佳實踐，參考現有測試實現
- [ ] **企業標準**：測試覆蓋完整，關鍵業務邏輯必須有單元測試
- [ ] **邏輯一致性**：測試用例完整，覆蓋正常流程和異常流程
- [ ] **符合常理**：測試真正驗證功能，文檔與代碼一致

---

### 開發後檢查（完整驗證流程）

#### 1. 代碼質量檢查

- [ ] **類型檢查**：所有層級通過 TypeScript 編譯（`yarn type-check`）
- [ ] **代碼檢查**：所有層級通過 ESLint 檢查（`yarn lint`）
- [ ] **樣式檢查**：所有層級通過 Stylelint 檢查（`yarn lint:style`）
- [ ] **構建檢查**：項目構建成功（`yarn build`）

#### 2. 功能驗證

- [ ] **單元測試**：所有測試通過（`yarn test`）
- [ ] **運行時檢查**：啟動開發服務器，功能在瀏覽器中正常工作
- [ ] **集成測試**：與相關模組的集成測試通過（如需要）

#### 3. 企業標準最終檢查

- [ ] **常見做法檢查**：
  - [ ] 是否符合 Angular/TypeScript/ng-alain 最佳實踐？
  - [ ] 是否參考了項目中已有的類似實現？
  - [ ] UI/UX 是否符合常規？
  - [ ] 是否避免了不必要的創新？

- [ ] **企業標準檢查**：
  - [ ] 代碼結構是否清晰（分層架構、依賴方向）？
  - [ ] 職責分離是否明確（單一職責原則）？
  - [ ] 錯誤處理是否完善（所有異步操作都有錯誤處理）？
  - [ ] 狀態管理是否規範（使用 Signals，避免全局狀態污染）？
  - [ ] 測試覆蓋是否完整（≥80% 服務層，100% 關鍵業務邏輯）？

- [ ] **邏輯一致性檢查**：
  - [ ] 數據流是否清晰（Component → Facade → Service → Repository）？
  - [ ] 命名是否語義化（能清楚表達意圖）？
  - [ ] 條件判斷是否合理（避免複雜嵌套）？
  - [ ] 組件初始化順序是否正確（優先加載主要功能）？
  - [ ] 狀態更新時機是否正確？

- [ ] **常理檢查**：
  - [ ] 功能是否真正可用（不是"看起來完成"）？
  - [ ] 用戶體驗是否良好（符合使用習慣）？
  - [ ] 是否避免了過度設計（簡單有效的方案）？
  - [ ] 是否及時驗證（構建檢查、運行時檢查）？
  - [ ] 文檔與代碼是否一致？

#### 4. 文檔更新

- [ ] README 已更新（如需要）
- [ ] API 文檔已更新（如需要）
- [ ] 架構文檔已更新（如需要）
- [ ] 資料庫文檔已更新（如需要新表）

#### 5. 代碼審查

- [ ] 代碼審查通過
- [ ] 所有反饋已處理
- [ ] 代碼已合併到主分支

---

### ⚠️ 重要提醒

**如果任何一項檢查不通過，必須修復後才能標記為完成。**

**四個核心原則必須全部滿足**：
1. ✅ 常見做法（Common Practices）
2. ✅ 企業標準（Enterprise Standards）
3. ✅ 符合邏輯（Logical Consistency）
4. ✅ 符合常理（Common Sense）

---

## 🚨 錯誤處理流程

### 通用錯誤處理流程

**執行流程**：
```
開始執行步驟
  ↓
執行開發步驟
  ↓
檢查完成標準
  ├─ 全部通過 → 檢查企業標準
  │   ├─ 全部通過 → 進入下一步
  │   └─ 部分失敗 → 執行修復 → 重新檢查
  └─ 部分失敗 → 執行錯誤處理流程
      ├─ 識別錯誤類型
      ├─ 選擇修復策略
      ├─ 執行修復
      ├─ 重新驗證
      ├─ 修復成功 → 重新檢查完成標準
      └─ 修復失敗 → 記錄問題 → 尋求協助
```

---

### 步驟 1：Types 層錯誤處理

#### 錯誤 1：類型定義錯誤

**識別**：
- `yarn type-check` 輸出類型錯誤
- 錯誤訊息包含 `Type 'xxx' is not assignable`
- 錯誤訊息包含 `Property 'xxx' does not exist on type`

**修復步驟**：
1. 檢查錯誤訊息中的文件路徑和行號
2. 檢查類型定義是否與資料庫結構一致
3. 使用 Supabase MCP 重新生成類型（如需要）
4. 檢查類型導出鏈是否完整
5. 重新執行 `yarn type-check`

**驗證**：
- `yarn type-check` 通過
- 無類型錯誤輸出

---

#### 錯誤 2：導入路徑錯誤

**識別**：
- `Cannot find module '@core'`
- `Cannot find module '@shared'`
- `Module not found: Can't resolve '@core/infra/types'`

**修復步驟**：
1. 檢查 `tsconfig.json` 路徑配置
   ```json
   {
     "paths": {
       "@core": ["src/app/core/index"],
       "@shared": ["src/app/shared/index"]
     }
   }
   ```
2. 檢查導出鏈是否完整（`index.ts` 文件）
   - `core/infra/types/index.ts` 是否導出類型？
   - `core/index.ts` 是否導出 `infra/types`？
3. 檢查是否有循環依賴
4. 檢查路徑別名是否使用正確（禁止深層路徑，如 `@core/infra/types`）
5. 重新執行 `yarn type-check`

**驗證**：
- `yarn type-check` 通過
- 無導入錯誤輸出

---

#### 錯誤 3：類型導出缺失

**識別**：
- `'xxx' is declared but its value is never read`
- `Cannot find name 'xxx'`

**修復步驟**：
1. 檢查類型是否在對應的 `index.ts` 中導出
2. 檢查導出鏈是否完整：
   ```
   具體文件 → 子模組 index.ts → 根模組 index.ts
   ```
3. 確保使用 `export * from './xxx'` 或 `export { xxx } from './xxx'`
4. 重新執行 `yarn type-check`

**驗證**：
- `yarn type-check` 通過
- 類型可以正確導入

---

### 步驟 2：Repositories 層錯誤處理

#### 錯誤 1：BaseRepository 繼承錯誤

**識別**：
- `Class 'xxx' incorrectly extends base class 'BaseRepository'`
- `Property 'tableName' is missing`

**修復步驟**：
1. 檢查是否正確繼承 `BaseRepository`
2. 檢查 `tableName` 是否設置（必須是 `protected abstract tableName: string`）
3. 檢查類型參數是否正確（Entity, Insert, Update）
4. 檢查 `tableName` 是否為 snake_case
5. 重新執行 `yarn type-check`

**驗證**：
- `yarn type-check` 通過
- Repository 可以正常實例化

---

#### 錯誤 2：查詢方法錯誤

**識別**：
- `Property 'xxx' does not exist on type`
- 查詢結果類型不匹配

**修復步驟**：
1. 檢查查詢方法的返回類型是否正確
2. 檢查 `filters` 中的字段名是否正確（camelCase，會自動轉換為 snake_case）
3. 檢查 `QueryOptions` 參數是否正確使用
4. 檢查是否正確使用 `Observable` 類型
5. 重新執行 `yarn type-check`

**驗證**：
- `yarn type-check` 通過
- 查詢方法可以正常調用

---

### 步驟 3：Models 層錯誤處理

#### 錯誤 1：類型提取錯誤

**識別**：
- `Type 'xxx' does not exist`
- `Cannot find name 'xxx'`

**修復步驟**：
1. 檢查是否正確從 `@core` 導入類型
2. 檢查類型是否在 `core/infra/types` 中定義
3. 檢查類型導出鏈是否完整
4. 重新執行 `yarn type-check`

**驗證**：
- `yarn type-check` 通過
- 類型可以正確使用

---

#### 錯誤 2：枚舉定義錯誤

**識別**：
- `Enum member 'xxx' has no initializer`
- 枚舉值與資料庫值不匹配

**修復步驟**：
1. 檢查枚舉值是否與資料庫中的值一致
2. 檢查枚舉是否正確導出
3. 檢查枚舉使用是否正確
4. 重新執行 `yarn type-check`

**驗證**：
- `yarn type-check` 通過
- 枚舉可以正確使用

---

### 步驟 4：Services 層錯誤處理

#### 錯誤 1：Signals 使用錯誤

**識別**：
- `Property 'xxx' does not exist on type 'Signal'`
- 狀態更新錯誤
- 無限加載問題

**修復步驟**：
1. 檢查是否正確使用 `signal()` 創建狀態
2. 檢查是否正確使用 `computed()` 創建派生狀態
3. 檢查是否正確暴露 `ReadonlySignal`（使用 `.asReadonly()`）
4. 檢查 loading 狀態是否配對設置和清除
5. 檢查是否有循環依賴導致無限更新
6. 重新執行 `yarn type-check` 和運行時檢查

**驗證**：
- `yarn type-check` 通過
- 運行時無無限加載問題
- 狀態更新正確

---

#### 錯誤 2：錯誤處理缺失

**識別**：
- 異步操作沒有錯誤處理
- 錯誤沒有正確捕獲和顯示

**修復步驟**：
1. 檢查所有異步操作是否都有 `try-catch`
2. 檢查錯誤是否正確設置到 `errorState`
3. 檢查錯誤是否正確清除（在成功時）
4. 檢查錯誤提示是否用戶友好
5. 重新執行運行時檢查

**驗證**：
- 所有異步操作都有錯誤處理
- 錯誤提示用戶友好
- 錯誤狀態正確管理

---

#### 錯誤 3：依賴注入錯誤

**識別**：
- `NullInjectorError: No provider for xxx`
- `Cannot read property 'xxx' of undefined`

**修復步驟**：
1. 檢查是否正確使用 `inject()` 進行依賴注入
2. 檢查 Service 是否使用 `@Injectable({ providedIn: 'root' })`
3. 檢查 Repository 是否正確導出和注入
4. 檢查是否有循環依賴
5. 重新執行運行時檢查

**驗證**：
- 運行時無依賴注入錯誤
- 所有依賴正確注入

---

### 步驟 5：Facades 層錯誤處理

#### 錯誤 1：Service 協調錯誤

**識別**：
- 多個 Services 狀態不一致
- 狀態更新順序錯誤

**修復步驟**：
1. 檢查 Facade 是否正確協調多個 Services
2. 檢查狀態更新順序是否正確
3. 檢查是否有競態條件
4. 檢查是否正確使用 `effect()` 處理副作用
5. 重新執行運行時檢查

**驗證**：
- 多個 Services 狀態一致
- 狀態更新順序正確

---

#### 錯誤 2：錯誤處理整合錯誤

**識別**：
- 錯誤沒有正確整合到 ErrorStateService
- 錯誤沒有正確傳播

**修復步驟**：
1. 檢查是否正確注入 `ErrorStateService`
2. 檢查是否正確調用 `errorState.setError()`
3. 檢查錯誤是否正確傳播給組件
4. 重新執行運行時檢查

**驗證**：
- 錯誤正確整合到 ErrorStateService
- 錯誤正確傳播給組件

---

### 步驟 6：Routes/Components 層錯誤處理

#### 錯誤 1：SHARED_IMPORTS 使用錯誤

**識別**：
- `'SHARED_IMPORTS' is not defined`
- 組件無法正常渲染

**修復步驟**：
1. 檢查是否正確導入 `SHARED_IMPORTS`（從 `@shared`）
2. 檢查是否在 `imports` 數組中使用 `SHARED_IMPORTS`
3. 檢查是否需要額外導入（如需要，記錄原因）
4. 重新執行 `yarn type-check` 和運行時檢查

**驗證**：
- `yarn type-check` 通過
- 組件正常渲染

---

#### 錯誤 2：Facade 使用錯誤

**識別**：
- `Cannot read property 'xxx' of undefined`
- 狀態無法正確獲取

**修復步驟**：
1. 檢查是否正確注入 Facade（使用 `inject()`）
2. 檢查是否正確獲取狀態（使用 `facade.state()`，注意括號）
3. 檢查是否正確調用方法
4. 重新執行運行時檢查

**驗證**：
- 運行時無錯誤
- 狀態正確獲取和顯示

---

### 通用驗證結果解讀指南

#### TypeScript 編譯檢查（`yarn type-check`）

**成功標準**：
- 無錯誤輸出
- 退出碼為 0
- 顯示 "Found 0 errors"

**失敗處理**：
1. **類型錯誤**：
   - 檢查錯誤訊息中的文件路徑和行號
   - 修復類型定義或導入路徑
   - 重新執行檢查

2. **導入錯誤**：
   - 檢查路徑別名是否正確（`@core`、`@shared`）
   - 檢查導出鏈是否完整
   - 檢查是否有循環依賴

3. **常見錯誤模式**：
   - `Cannot find module '@core'` → 檢查 `tsconfig.json` 路徑配置
   - `Property 'xxx' does not exist` → 檢查類型定義是否正確導出
   - `Type 'xxx' is not assignable` → 檢查類型是否匹配

---

#### ESLint 檢查（`yarn lint`）

**成功標準**：
- 無錯誤輸出
- 退出碼為 0
- 顯示 "✔ No problems"

**失敗處理**：
1. **可自動修復的錯誤**：
   - 執行 `yarn lint --fix` 自動修復
   - 重新執行檢查

2. **需要手動修復的錯誤**：
   - 檢查錯誤訊息中的規則名稱
   - 參考 ESLint 規則文檔
   - 手動修復後重新執行檢查

3. **常見錯誤模式**：
   - `'xxx' is assigned a value but never used` → 移除未使用的變量
   - `Unexpected any` → 使用具體類型替代 `any`
   - `Missing return type` → 添加返回類型註解

---

#### Stylelint 檢查（`yarn lint:style`）

**成功標準**：
- 無錯誤輸出
- 退出碼為 0

**失敗處理**：
1. **可自動修復的錯誤**：
   - 執行 `yarn lint:style --fix` 自動修復
   - 重新執行檢查

2. **需要手動修復的錯誤**：
   - 檢查錯誤訊息中的規則名稱
   - 參考 Stylelint 規則文檔
   - 手動修復後重新執行檢查

---

#### 構建檢查（`yarn build`）

**成功標準**：
- 構建成功
- 無錯誤輸出
- 生成 `dist/` 目錄

**失敗處理**：
1. **編譯錯誤**：
   - 檢查錯誤訊息中的文件路徑和行號
   - 修復編譯錯誤
   - 重新執行構建

2. **依賴錯誤**：
   - 檢查 `package.json` 依賴是否正確
   - 執行 `yarn install` 重新安裝依賴
   - 重新執行構建

---

### 並行開發協調機制

#### 步驟 2 和步驟 3 並行開發

**協調方式**：
1. **同時開始**：Repositories 層和 Models 層可以同時開始開發
2. **獨立開發**：兩者都只依賴 Types 層，可以獨立開發
3. **協調檢查點**：
   - 完成 Types 層後，同時開始 Repositories 和 Models
   - 兩者都完成後，再進入 Services 層

**檢查流程**：
```
Types 層完成
  ↓
並行開發
  ├─ Repositories 層開發
  │   └─ 完成後等待 Models 層
  └─ Models 層開發
      └─ 完成後等待 Repositories 層
  ↓
兩者都完成
  ↓
進入 Services 層
```

**注意事項**：
- 確保兩者都通過各自的檢查清單
- 確保兩者都通過 TypeScript 編譯檢查
- 確保兩者都正確導出

---

## ❓ 常見問題 FAQ

### Q1：如何判斷是否需要創建業務模組類型文件？

**A**：參考「決策邏輯指南」中的「決策 1」。簡單來說：
- 如果 `database.types.ts` 已經包含所需類型，不需要創建
- 如果業務邏輯需要額外的類型定義（如枚舉、聯合類型），需要創建

---

### Q2：Types 層編譯失敗怎麼辦？

**A**：參考「錯誤處理流程」中的「步驟 1：Types 層錯誤處理」。常見原因：
1. 類型定義錯誤 → 檢查類型定義是否與資料庫結構一致
2. 導入路徑錯誤 → 檢查路徑別名和導出鏈
3. 類型導出缺失 → 檢查導出鏈完整性

---

### Q3：Repository 繼承 BaseRepository 後沒有自動獲得 CRUD 方法？

**A**：檢查以下幾點：
1. 是否正確繼承 `BaseRepository<Entity, Insert, Update>`
2. 是否設置了 `protected abstract tableName: string`
3. 是否正確導出 Repository
4. 重新執行 `yarn type-check` 檢查類型錯誤

---

### Q4：Service 層狀態管理出現無限加載問題？

**A**：檢查以下幾點：
1. loading 狀態是否配對設置和清除（`set(true)` 和 `set(false)`）
2. 是否有循環依賴導致無限更新
3. 是否在 `effect()` 中修改了依賴的狀態
4. 檢查是否有異步操作沒有正確完成

---

### Q5：Facade 層如何協調多個 Services？

**A**：
1. 注入多個 Services
2. 暴露統一的狀態接口（通過 Facade）
3. 在業務方法中協調多個 Services 的調用
4. 確保狀態更新順序正確
5. 整合錯誤處理和活動記錄

---

### Q6：組件中如何正確使用 Signals？

**A**：
1. 從 Facade 獲取 `ReadonlySignal`
2. 在模板中使用 `{{ signal() }}`（注意括號）
3. 在 TypeScript 中使用 `signal()` 獲取值
4. 使用 `computed()` 創建派生狀態
5. 使用 `effect()` 處理副作用（謹慎使用）

---

### Q7：如何處理並行開發的協調？

**A**：參考「並行開發協調機制」。關鍵點：
1. 確認兩者都只依賴已完成的前置步驟
2. 同時開始開發
3. 兩者都完成後再進入下一步
4. 確保兩者都通過各自的檢查清單

---

## 📦 新功能模組開發示例

### 通用開發流程示例

假設要開發一個新的業務模組（例如：財務、庫存、報表等），以下是完整的開發流程：

#### 1. 資料庫設計（如需要新表）

```sql
-- 示例：新業務表
CREATE TABLE new_feature_items (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  name VARCHAR(255) NOT NULL,
  status VARCHAR(20) NOT NULL DEFAULT 'active',
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  created_by UUID REFERENCES accounts(id),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);
```

#### 2. 開發順序（通用流程）

```
第 1 步：Types 層
  - 使用 Supabase MCP 生成/更新 database.types.ts（包含新表）
  - 創建 {feature}.types.ts（業務類型定義，如需要）

第 2 步：Repositories 層
  - 創建 {Feature}Repository（繼承 BaseRepository）
  - 實現基本 CRUD 和特定查詢方法

第 3 步：Models 層（可與 Repositories 並行）
  - 創建 {feature}.models.ts
  - 定義業務相關枚舉和類型
  - 定義業務相關接口

第 4 步：Services 層
  - 創建 {Feature}Service
  - 實現業務邏輯
  - 使用 Signals 管理狀態

第 5 步：Facades 層
  - 創建 {Feature}Facade
  - 協調相關 Services
  - 提供統一的對外接口

第 6 步：Routes/Components 層
  - 創建 {Feature}ListComponent
  - 創建 {Feature}DetailComponent（如需要）
  - 配置路由

第 7 步：測試與文檔
  - 編寫單元測試
  - 更新文檔
```

#### 3. 文件結構（通用模板）

```
src/app/
├── core/
│   ├── infra/
│   │   ├── types/
│   │   │   ├── database.types.ts (更新，如需要)
│   │   │   └── {feature}.types.ts (新增，如需要)
│   │   └── repositories/
│   │       └── {feature}-item.repository.ts (新增)
│   └── facades/
│       └── {feature}.facade.ts (新增)
├── shared/
│   ├── models/
│   │   └── {feature}.models.ts (新增)
│   └── services/
│       └── {feature}/
│           └── {feature}-item.service.ts (新增)
└── routes/
    └── {feature}/
        ├── {feature}-list/
        │   └── {feature}-list.component.ts (新增)
        └── {feature}.routes.ts (新增)
```

**命名規範**：
- `{feature}` 替換為實際功能名稱（如：finance、inventory、report）
- 使用 kebab-case 命名文件
- 使用 PascalCase 命名類和接口

#### 4. 開發檢查點

每個步驟完成後，檢查：

- [ ] **Types 層**：類型定義完整，通過 `yarn type-check`
- [ ] **Repositories 層**：Repository 繼承 BaseRepository，基本 CRUD 可用
- [ ] **Models 層**：業務模型和枚舉定義完整
- [ ] **Services 層**：業務邏輯實現，Signals 狀態管理正確
- [ ] **Facades 層**：協調 Services，提供統一接口
- [ ] **Routes/Components 層**：UI 組件實現，路由配置正確
- [ ] **測試與文檔**：測試通過，文檔更新

#### 5. 適用場景

此開發順序適用於：

- ✅ 新業務模組（財務、庫存、報表等）
- ✅ 擴展現有模組功能
- ✅ 新增資料表相關功能
- ✅ 重構現有功能模組

**不適用於**：
- ❌ 純 UI 組件（不需要資料庫操作）
- ❌ 工具函數或工具類
- ❌ 配置類文件

---

## 📚 相關文檔

- [架構層級完整性檢查報告](./架構層級完整性檢查報告-2025-01-15.md)
- [架構依賴關係檢查報告](./架構依賴關係檢查報告-2025-01-19.md)
- [開發工作流程](./28-開發工作流程.md)
- [API 設計規範](../../.cursor/rules/api-design.mdc)
- [錯誤處理規範](../../.cursor/rules/error-handling.mdc)

---

**最後更新**：2025-01-19  
**維護者**：開發團隊
