# GitHub Copilot æ¸¬è©¦ç”¢ç”ŸæŒ‡ç¤º

> **ç›®çš„**ï¼šç‚º VS Code çš„ Copilot Chat æ¸¬è©¦ç”¢ç”ŸåŠŸèƒ½æä¾›çµ±ä¸€çš„è¦ç¯„ã€‚  
> ç¢ºä¿ç”¢ç”Ÿçš„æ¸¬è©¦ç¬¦åˆå°ˆæ¡ˆæ¨™æº–ï¼Œä½¿ç”¨ Karma + Jasmine æ¡†æ¶ã€‚

## ğŸ“‹ åŸºæœ¬åŸå‰‡

### æ¸¬è©¦æ¡†æ¶
- **å–®å…ƒæ¸¬è©¦**ï¼šKarma + Jasmine
- **æ¸¬è©¦æª”æ¡ˆ**ï¼š`*.spec.ts`
- **è¦†è“‹ç‡ç›®æ¨™**ï¼š70% ä»¥ä¸Šï¼ˆèªå¥ã€åˆ†æ”¯ã€å‡½æ•¸ã€è¡Œæ•¸ï¼‰

### æ¸¬è©¦èªè¨€
- **æ¸¬è©¦æè¿°ï¼ˆdescribe/itï¼‰ä½¿ç”¨æ­£é«”ä¸­æ–‡**
- **è®Šæ•¸èˆ‡å‡½æ•¸å‘½åä½¿ç”¨è‹±æ–‡**
- **è¨»è§£ä½¿ç”¨æ­£é«”ä¸­æ–‡**

### æ¸¬è©¦çµæ§‹
éµå¾ª AAA æ¨¡å¼ï¼ˆArrange / Act / Assertï¼‰ï¼š
1. **Arrange**ï¼šæº–å‚™æ¸¬è©¦è³‡æ–™èˆ‡ç’°å¢ƒ
2. **Act**ï¼šåŸ·è¡Œè¦æ¸¬è©¦çš„è¡Œç‚º
3. **Assert**ï¼šé©—è­‰çµæœ

## ğŸ§ª Angular Component æ¸¬è©¦

### åŸºæœ¬æ¨¡æ¿
```typescript
import { ComponentFixture, TestBed } from '@angular/core/testing';
import { ComponentName } from './component-name.component';
import { SHARED_IMPORTS } from '@shared';

describe('ComponentName', () => {
  let component: ComponentName;
  let fixture: ComponentFixture<ComponentName>;

  beforeEach(async () => {
    await TestBed.configureTestingModule({
      imports: [ComponentName, SHARED_IMPORTS]
    }).compileComponents();

    fixture = TestBed.createComponent(ComponentName);
    component = fixture.componentInstance;
    fixture.detectChanges();
  });

  it('æ‡‰è©²å»ºç«‹å…ƒä»¶', () => {
    expect(component).toBeTruthy();
  });

  // æ›´å¤šæ¸¬è©¦...
});
```

### Signal Input/Output æ¸¬è©¦
```typescript
describe('Signal Input/Output æ¸¬è©¦', () => {
  it('æ‡‰è©²æ­£ç¢ºæ¥æ”¶ input signal', () => {
    // Arrange
    const testValue = 'test';
    
    // Act
    fixture.componentRef.setInput('inputName', testValue);
    fixture.detectChanges();
    
    // Assert
    expect(component.inputName()).toBe(testValue);
  });

  it('æ‡‰è©²æ­£ç¢ºç™¼é€ output signal', () => {
    // Arrange
    const outputSpy = jasmine.createSpy('output');
    component.outputName.subscribe(outputSpy);
    
    // Act
    component.triggerOutput();
    
    // Assert
    expect(outputSpy).toHaveBeenCalledWith(expectedValue);
  });
});
```

### Computed Signal æ¸¬è©¦
```typescript
describe('Computed Signal æ¸¬è©¦', () => {
  it('æ‡‰è©²æ ¹æ“šè¼¸å…¥è¨ˆç®—æ­£ç¢ºçš„å€¼', () => {
    // Arrange
    component.baseValue.set(10);
    
    // Act
    const result = component.computedValue();
    
    // Assert
    expect(result).toBe(20); // å‡è¨­æ˜¯ baseValue * 2
  });
});
```

### OnPush å…ƒä»¶æ¸¬è©¦
```typescript
describe('OnPush å…ƒä»¶æ¸¬è©¦', () => {
  it('æ‡‰è©²åœ¨ signal æ›´æ–°å¾Œè§¸ç™¼è®Šæ›´æª¢æ¸¬', () => {
    // Arrange
    const initialValue = component.value();
    
    // Act
    component.value.set('new value');
    fixture.detectChanges();
    
    // Assert
    const element = fixture.nativeElement.querySelector('.value');
    expect(element.textContent).toBe('new value');
  });
});
```

### æ¨¡æ¿æ¸¬è©¦ï¼ˆModern Control Flowï¼‰
```typescript
describe('æ¨¡æ¿æ¸¬è©¦', () => {
  it('æ‡‰è©²æ ¹æ“šæ¢ä»¶é¡¯ç¤ºæˆ–éš±è—å…ƒç´  (@if)', () => {
    // Arrange
    component.showElement.set(false);
    fixture.detectChanges();
    
    // Act & Assert - éš±è—
    let element = fixture.nativeElement.querySelector('.conditional');
    expect(element).toBeNull();
    
    // Act - é¡¯ç¤º
    component.showElement.set(true);
    fixture.detectChanges();
    
    // Assert
    element = fixture.nativeElement.querySelector('.conditional');
    expect(element).not.toBeNull();
  });

  it('æ‡‰è©²æ­£ç¢ºæ¸²æŸ“åˆ—è¡¨ (@for with track)', () => {
    // Arrange
    const items = [{ id: 1, name: 'é …ç›®1' }, { id: 2, name: 'é …ç›®2' }];
    component.items.set(items);
    
    // Act
    fixture.detectChanges();
    
    // Assert
    const listItems = fixture.nativeElement.querySelectorAll('.list-item');
    expect(listItems.length).toBe(2);
    expect(listItems[0].textContent).toContain('é …ç›®1');
  });
});
```

## ğŸ”§ Service æ¸¬è©¦

### åŸºæœ¬æ¨¡æ¿
```typescript
import { TestBed } from '@angular/core/testing';
import { ServiceName } from './service-name.service';

describe('ServiceName', () => {
  let service: ServiceName;

  beforeEach(() => {
    TestBed.configureTestingModule({});
    service = TestBed.inject(ServiceName);
  });

  it('æ‡‰è©²å»ºç«‹æœå‹™', () => {
    expect(service).toBeTruthy();
  });

  // æ›´å¤šæ¸¬è©¦...
});
```

### Signal State æ¸¬è©¦
```typescript
describe('Signal State ç®¡ç†', () => {
  it('æ‡‰è©²æ­£ç¢ºæ›´æ–° signal ç‹€æ…‹', () => {
    // Arrange
    const initialState = service.state();
    
    // Act
    service.updateState({ value: 'new' });
    
    // Assert
    expect(service.state()).not.toBe(initialState);
    expect(service.state().value).toBe('new');
  });

  it('æ‡‰è©²æ­£ç¢ºè¨ˆç®— computed signal', () => {
    // Arrange
    service.count.set(5);
    
    // Act
    const doubled = service.doubledCount();
    
    // Assert
    expect(doubled).toBe(10);
  });
});
```

### HTTP è«‹æ±‚æ¸¬è©¦ï¼ˆä½¿ç”¨ Supabaseï¼‰
```typescript
import { provideHttpClient } from '@angular/common/http';
import { HttpTestingController, provideHttpClientTesting } from '@angular/common/http/testing';

describe('HTTP è«‹æ±‚æ¸¬è©¦', () => {
  let httpMock: HttpTestingController;

  beforeEach(() => {
    TestBed.configureTestingModule({
      providers: [
        ServiceName,
        provideHttpClient(),
        provideHttpClientTesting()
      ]
    });
    
    service = TestBed.inject(ServiceName);
    httpMock = TestBed.inject(HttpTestingController);
  });

  afterEach(() => {
    httpMock.verify(); // ç¢ºä¿æ²’æœ‰æœªè™•ç†çš„è«‹æ±‚
  });

  it('æ‡‰è©²æˆåŠŸå–å¾—è³‡æ–™', (done) => {
    // Arrange
    const mockData = [{ id: 1, name: 'æ¸¬è©¦' }];
    
    // Act
    service.getData().subscribe(data => {
      // Assert
      expect(data).toEqual(mockData);
      done();
    });

    // Mock HTTP å›æ‡‰
    const req = httpMock.expectOne('/api/data');
    expect(req.request.method).toBe('GET');
    req.flush(mockData);
  });

  it('æ‡‰è©²è™•ç†éŒ¯èª¤æƒ…æ³', (done) => {
    // Act
    service.getData().subscribe({
      error: (error) => {
        // Assert
        expect(error.status).toBe(500);
        done();
      }
    });

    // Mock éŒ¯èª¤å›æ‡‰
    const req = httpMock.expectOne('/api/data');
    req.flush('Server Error', { status: 500, statusText: 'Internal Server Error' });
  });
});
```

### Async æ–¹æ³•æ¸¬è©¦
```typescript
describe('Async æ–¹æ³•æ¸¬è©¦', () => {
  it('æ‡‰è©²æ­£ç¢ºåŸ·è¡ŒéåŒæ­¥æ“ä½œ', async () => {
    // Arrange
    const expectedResult = 'success';
    
    // Act
    const result = await service.asyncMethod();
    
    // Assert
    expect(result).toBe(expectedResult);
  });

  it('æ‡‰è©²è™•ç†éåŒæ­¥éŒ¯èª¤', async () => {
    // Arrange
    spyOn(service, 'failingMethod').and.returnValue(
      Promise.reject(new Error('Async Error'))
    );
    
    // Act & Assert
    await expectAsync(service.failingMethod()).toBeRejectedWithError('Async Error');
  });
});
```

## ğŸ­ Mock èˆ‡ Spy

### Mock Service
```typescript
describe('ä½¿ç”¨ Mock Service', () => {
  let mockService: jasmine.SpyObj<DependencyService>;

  beforeEach(() => {
    // å»ºç«‹ Mock Service
    mockService = jasmine.createSpyObj('DependencyService', ['getData', 'updateData']);
    
    TestBed.configureTestingModule({
      providers: [
        ComponentName,
        { provide: DependencyService, useValue: mockService }
      ]
    });
  });

  it('æ‡‰è©²å‘¼å«ä¾è³´æœå‹™çš„æ–¹æ³•', () => {
    // Arrange
    mockService.getData.and.returnValue(of({ id: 1, name: 'æ¸¬è©¦' }));
    
    // Act
    component.loadData();
    
    // Assert
    expect(mockService.getData).toHaveBeenCalled();
  });
});
```

### Spy æ–¹æ³•
```typescript
describe('ä½¿ç”¨ Spy', () => {
  it('æ‡‰è©²ç›£æ§æ–¹æ³•å‘¼å«', () => {
    // Arrange
    const spy = spyOn(component, 'privateMethod').and.returnValue('mocked');
    
    // Act
    component.publicMethod();
    
    // Assert
    expect(spy).toHaveBeenCalled();
    expect(spy).toHaveBeenCalledWith(expectedArgs);
  });

  it('æ‡‰è©²ç›£æ§ signal effect', () => {
    // Arrange
    const effectSpy = jasmine.createSpy('effect');
    
    // æ³¨æ„ï¼šæ¸¬è©¦ effect éœ€è¦ç‰¹æ®Šè™•ç†
    TestBed.runInInjectionContext(() => {
      effect(() => {
        effectSpy(component.value());
      });
    });
    
    // Act
    component.value.set('new value');
    
    // Assert
    expect(effectSpy).toHaveBeenCalledWith('new value');
  });
});
```

## ğŸ§© NG-ZORRO å…ƒä»¶æ¸¬è©¦

### è¡¨å–®å…ƒä»¶æ¸¬è©¦
```typescript
import { NzFormModule } from 'ng-zorro-antd/form';

describe('NG-ZORRO è¡¨å–®æ¸¬è©¦', () => {
  beforeEach(async () => {
    await TestBed.configureTestingModule({
      imports: [ComponentName, SHARED_IMPORTS, NzFormModule]
    }).compileComponents();
  });

  it('æ‡‰è©²é©—è­‰è¡¨å–®æ¬„ä½', () => {
    // Arrange
    const form = component.validateForm;
    
    // Act - è¨­å®šç„¡æ•ˆå€¼
    form.controls['email'].setValue('invalid-email');
    form.controls['email'].markAsDirty();
    form.controls['email'].updateValueAndValidity();
    
    // Assert
    expect(form.controls['email'].valid).toBeFalsy();
    expect(form.controls['email'].hasError('email')).toBeTruthy();
  });

  it('æ‡‰è©²æäº¤æœ‰æ•ˆè¡¨å–®', () => {
    // Arrange
    const submitSpy = spyOn(component, 'submitForm');
    const form = component.validateForm;
    
    // Act - è¨­å®šæœ‰æ•ˆå€¼
    form.controls['email'].setValue('test@example.com');
    form.controls['password'].setValue('password123');
    
    // Trigger submit
    const submitButton = fixture.nativeElement.querySelector('button[type="submit"]');
    submitButton.click();
    fixture.detectChanges();
    
    // Assert
    expect(form.valid).toBeTruthy();
    expect(submitSpy).toHaveBeenCalled();
  });
});
```

### è¡¨æ ¼å…ƒä»¶æ¸¬è©¦
```typescript
import { NzTableModule } from 'ng-zorro-antd/table';

describe('NG-ZORRO è¡¨æ ¼æ¸¬è©¦', () => {
  it('æ‡‰è©²æ­£ç¢ºé¡¯ç¤ºè³‡æ–™è¡Œ', () => {
    // Arrange
    const data = [
      { id: 1, name: 'é …ç›®1' },
      { id: 2, name: 'é …ç›®2' }
    ];
    component.dataSource.set(data);
    
    // Act
    fixture.detectChanges();
    
    // Assert
    const rows = fixture.nativeElement.querySelectorAll('tbody tr');
    expect(rows.length).toBe(2);
  });

  it('æ‡‰è©²æ­£ç¢ºæ’åºè³‡æ–™', () => {
    // Arrange
    component.dataSource.set([
      { id: 2, name: 'B' },
      { id: 1, name: 'A' }
    ]);
    fixture.detectChanges();
    
    // Act - é»æ“Šæ’åº
    const sortHeader = fixture.nativeElement.querySelector('th[nzSortOrder]');
    sortHeader.click();
    fixture.detectChanges();
    
    // Assert
    const firstRow = fixture.nativeElement.querySelector('tbody tr:first-child td');
    expect(firstRow.textContent).toContain('A');
  });
});
```

## ğŸ¯ æ¸¬è©¦è¦†è“‹é‡é»

### å¿…é ˆæ¸¬è©¦çš„é …ç›®
1. **å…ƒä»¶å»ºç«‹**ï¼šåŸºæœ¬çš„ `toBeTruthy()` æ¸¬è©¦
2. **Signal ç‹€æ…‹**ï¼šæ‰€æœ‰ signal çš„ get/set è¡Œç‚º
3. **Computed Signals**ï¼šè¨ˆç®—é‚è¼¯æ­£ç¢ºæ€§
4. **Input/Output**ï¼šè³‡æ–™å‚³éèˆ‡äº‹ä»¶ç™¼é€
5. **è¡¨å–®é©—è­‰**ï¼šæ‰€æœ‰é©—è­‰è¦å‰‡
6. **HTTP è«‹æ±‚**ï¼šæˆåŠŸèˆ‡éŒ¯èª¤æƒ…æ³
7. **éŒ¯èª¤è™•ç†**ï¼šcatch å€å¡Šé‚è¼¯
8. **æ¢ä»¶æ¸²æŸ“**ï¼š`@if` / `@switch` åˆ†æ”¯
9. **åˆ—è¡¨æ¸²æŸ“**ï¼š`@for` è¿´åœˆé‚è¼¯

### å»ºè­°æ¸¬è©¦çš„é …ç›®
1. **Effect å‰¯ä½œç”¨**ï¼šsignal effect è¡Œç‚º
2. **è·¯ç”±å°èˆª**ï¼šRouter äº’å‹•
3. **æ¬Šé™æª¢æŸ¥**ï¼šACL åˆ¤æ–·
4. **Edge Cases**ï¼šé‚Šç•Œæ¢ä»¶èˆ‡ç‰¹æ®Šæƒ…æ³
5. **æ•ˆèƒ½**ï¼šå¤§é‡è³‡æ–™è™•ç†

## ğŸš« æ¸¬è©¦åæ¨¡å¼

### é¿å…çš„åšæ³•
```typescript
// âŒ ä¸å¥½ï¼šæ¸¬è©¦å¯¦ä½œç´°ç¯€
it('æ‡‰è©²å‘¼å«ç§æœ‰æ–¹æ³•', () => {
  spyOn(component as any, '_privateMethod');
  // ...
});

// âœ… å¥½ï¼šæ¸¬è©¦å…¬é–‹è¡Œç‚º
it('æ‡‰è©²æ›´æ–°é¡¯ç¤ºçš„è³‡æ–™', () => {
  component.loadData();
  expect(component.displayData()).toEqual(expectedData);
});

// âŒ ä¸å¥½ï¼šéåº¦ä¾è³´å¯¦ä½œ
it('æ‡‰è©²è¨­å®š loading ç‚º true å†è¨­ç‚º false', () => {
  expect(component.loading()).toBe(false);
  component.loadData();
  expect(component.loading()).toBe(true);
  // ...
});

// âœ… å¥½ï¼šæ¸¬è©¦çµæœè€Œééç¨‹
it('æ‡‰è©²æˆåŠŸè¼‰å…¥è³‡æ–™', async () => {
  await component.loadData();
  expect(component.data()).toEqual(expectedData);
  expect(component.loading()).toBe(false);
});
```

## ğŸ“‹ æ¸¬è©¦æª¢æŸ¥æ¸…å–®

æäº¤æ¸¬è©¦å‰ç¢ºèªï¼š
- [ ] æ‰€æœ‰æ¸¬è©¦æè¿°ä½¿ç”¨æ­£é«”ä¸­æ–‡
- [ ] éµå¾ª AAA æ¨¡å¼
- [ ] æ¯å€‹æ¸¬è©¦åªé©—è­‰ä¸€å€‹è¡Œç‚º
- [ ] æœ‰é©ç•¶çš„ arrange / setup
- [ ] ä½¿ç”¨æœ‰æ„ç¾©çš„è®Šæ•¸åç¨±
- [ ] Mock å¤–éƒ¨ä¾è³´ï¼ˆHTTPã€Serviceï¼‰
- [ ] æ¸¬è©¦è¦†è“‹ä¸»è¦é‚è¼¯è·¯å¾‘
- [ ] æ¸¬è©¦æˆåŠŸèˆ‡å¤±æ•—æƒ…æ³
- [ ] æ¸…ç†æ¸¬è©¦è³‡æºï¼ˆafterEachï¼‰
- [ ] åŸ·è¡Œ `yarn test --watch=false` é€šé

## ğŸ”§ åŸ·è¡Œæ¸¬è©¦

### åŸºæœ¬æŒ‡ä»¤
```bash
# åŸ·è¡Œæ‰€æœ‰æ¸¬è©¦
yarn test

# åŸ·è¡Œæ¸¬è©¦ï¼ˆä¸ç›£çœ‹ï¼‰
yarn test --watch=false

# åŸ·è¡Œæ¸¬è©¦ä¸¦ç”¢ç”Ÿè¦†è“‹ç‡å ±å‘Š
yarn test-coverage

# åŸ·è¡Œç‰¹å®šæª”æ¡ˆçš„æ¸¬è©¦
yarn test --include='**/component-name.component.spec.ts'
```

### è¦†è“‹ç‡è¦æ±‚
- **èªå¥è¦†è“‹ç‡ï¼ˆStatementsï¼‰**ï¼šâ‰¥ 70%
- **åˆ†æ”¯è¦†è“‹ç‡ï¼ˆBranchesï¼‰**ï¼šâ‰¥ 70%
- **å‡½æ•¸è¦†è“‹ç‡ï¼ˆFunctionsï¼‰**ï¼šâ‰¥ 70%
- **è¡Œæ•¸è¦†è“‹ç‡ï¼ˆLinesï¼‰**ï¼šâ‰¥ 70%

## ğŸ”— ç›¸é—œè³‡æº

- [Jasmine å®˜æ–¹æ–‡ä»¶](https://jasmine.github.io/)
- [Angular Testing æŒ‡å—](https://angular.dev/guide/testing)
- `.cursor/rules/testing.mdc`ï¼šå®Œæ•´æ¸¬è©¦è¦ç¯„
- `docs/31-æ¸¬è©¦æŒ‡å—.md`ï¼šå°ˆæ¡ˆæ¸¬è©¦æŒ‡å—
- `.github/agents/domain/testing-agent.md`ï¼šæ¸¬è©¦ä»£ç†

---

**ç‰ˆæœ¬**ï¼šv2.0ï¼ˆ2025-11-18ï¼‰  
**ç¶­è­·è€…**ï¼šé–‹ç™¼åœ˜éšŠ  
**æœ€å¾Œæ›´æ–°**ï¼š2025-01-15
